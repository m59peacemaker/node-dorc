function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const R = require('ramda');

var _require = require('child_process');

const spawn = _require.spawn,
      exec = _require.exec;

const format = require('chalk');
const split = require('split');
const prefixLines = require('prefix-stream-lines');
const through = require('throo');
const docker = require('../docker-api');

const color = c => {
  return through((push, chunk, enc, cb) => {
    push(format[c](chunk) + '\n');
    cb();
  });
};

const _buildImage = ({ file, context = './', tags = [], args = [] }) => {
  const tagArgs = R.flatten(tags.map(tag => ['-t', tag]));
  const buildArgs = R.pipe(R.toPairs, R.map(([key, value]) => ['--build-arg', `${ key }=${ value }`]), R.flatten)(args);
  const dockerArgs = ['build', ...tagArgs, ...buildArgs, '-f', file, context];
  process.stdout.write(`  > docker ${ dockerArgs.join(' ') }\n`);
  return spawn('docker', dockerArgs);
};

const buildImage = (serviceName, image) => new Promise((resolve, reject) => {
  const p = _buildImage(image);
  p.stdout.pipe(split()).pipe(color('yellow')).pipe(prefixLines(`${ serviceName } | `)).pipe(process.stdout);
  p.stderr.pipe(split()).pipe(color('red')).pipe(prefixLines(`${ serviceName } | `)).pipe(process.stderr);
  p.on('error', reject).on('close', exitCode => exitCode === 0 ? resolve() : reject(exitCode));
});

const removeDangling = imagesThatMatchedTags => {
  return Promise.all(imagesThatMatchedTags.map(image => docker.getImage(image.Id).then(info => {
    if (!info.RepoTags.length) {
      // no longer tagged (is dangling)
      process.stdout.write(`Removing dangling image ${ info.Id }, previously tagged "${ image.RepoTags.join(' ') }"\n`);
      return docker.rmi(info.Id);
    }
    return Promise.resolve();
  })));
};

const buildImageAndRemoveDangling = (() => {
  var _ref = _asyncToGenerator(function* (serviceName, image) {
    const imagesThatMatchTags = yield Promise.all(image.tags.map(function (tag) {
      return docker.getImage(tag).catch(function (err) {
        return undefined;
      });
    }));
    yield buildImage(serviceName, image);
    yield removeDangling(imagesThatMatchTags.filter(function (v) {
      return v !== undefined;
    }));
    return;
  });

  return function buildImageAndRemoveDangling(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

const buildImages = toBuild => {
  try {
    toBuild.forEach(([name, images]) => {
      images.forEach(image => {
        if (!(image.file && image.file.length)) {
          throw new Error(`no Dockerfile path given for "${ name }" service image`);
        }
      });
    });
  } catch (err) {
    return Promise.reject(err);
  }
  return toBuild.reduce((promise, [name, images]) => {
    return promise.then(() => {
      return images.reduce((promise, image) => {
        return promise.then(() => buildImageAndRemoveDangling(name, image));
      }, Promise.resolve());
    });
  }, Promise.resolve());
};

const filter = R.pipe(R.toPairs, R.map(R.over(R.lensIndex(1), R.view(R.lensProp('image')))), R.filter(R.pipe(R.view(R.lensIndex(1)), R.both(Array.isArray, R.complement(R.isEmpty)))));

const build = (selectedServices, config) => {
  return buildImages(filter(selectedServices));
};

module.exports = build;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvY21kcy9idWlsZC5qcyJdLCJuYW1lcyI6WyJSIiwicmVxdWlyZSIsInNwYXduIiwiZXhlYyIsImZvcm1hdCIsInNwbGl0IiwicHJlZml4TGluZXMiLCJ0aHJvdWdoIiwiZG9ja2VyIiwiY29sb3IiLCJjIiwicHVzaCIsImNodW5rIiwiZW5jIiwiY2IiLCJfYnVpbGRJbWFnZSIsImZpbGUiLCJjb250ZXh0IiwidGFncyIsImFyZ3MiLCJ0YWdBcmdzIiwiZmxhdHRlbiIsIm1hcCIsInRhZyIsImJ1aWxkQXJncyIsInBpcGUiLCJ0b1BhaXJzIiwia2V5IiwidmFsdWUiLCJkb2NrZXJBcmdzIiwicHJvY2VzcyIsInN0ZG91dCIsIndyaXRlIiwiam9pbiIsImJ1aWxkSW1hZ2UiLCJzZXJ2aWNlTmFtZSIsImltYWdlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwIiwic3RkZXJyIiwib24iLCJleGl0Q29kZSIsInJlbW92ZURhbmdsaW5nIiwiaW1hZ2VzVGhhdE1hdGNoZWRUYWdzIiwiYWxsIiwiZ2V0SW1hZ2UiLCJJZCIsInRoZW4iLCJpbmZvIiwiUmVwb1RhZ3MiLCJsZW5ndGgiLCJybWkiLCJidWlsZEltYWdlQW5kUmVtb3ZlRGFuZ2xpbmciLCJpbWFnZXNUaGF0TWF0Y2hUYWdzIiwiY2F0Y2giLCJ1bmRlZmluZWQiLCJmaWx0ZXIiLCJ2IiwiYnVpbGRJbWFnZXMiLCJ0b0J1aWxkIiwiZm9yRWFjaCIsIm5hbWUiLCJpbWFnZXMiLCJFcnJvciIsImVyciIsInJlZHVjZSIsInByb21pc2UiLCJvdmVyIiwibGVuc0luZGV4IiwidmlldyIsImxlbnNQcm9wIiwiYm90aCIsIkFycmF5IiwiaXNBcnJheSIsImNvbXBsZW1lbnQiLCJpc0VtcHR5IiwiYnVpbGQiLCJzZWxlY3RlZFNlcnZpY2VzIiwiY29uZmlnIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFNQSxJQUFJQyxRQUFRLE9BQVIsQ0FB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QUlBRSxPQUFPQyxPQUFQLEdBQWlCSixLQUFqQiIsImZpbGUiOiJidWlsZC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFIgPSByZXF1aXJlKCdyYW1kYScpXG5jb25zdCB7c3Bhd24sIGV4ZWN9ID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpXG5jb25zdCBmb3JtYXQgPSByZXF1aXJlKCdjaGFsaycpXG5jb25zdCBzcGxpdCA9IHJlcXVpcmUoJ3NwbGl0JylcbmNvbnN0IHByZWZpeExpbmVzID0gcmVxdWlyZSgncHJlZml4LXN0cmVhbS1saW5lcycpXG5jb25zdCB0aHJvdWdoID0gcmVxdWlyZSgndGhyb28nKVxuY29uc3QgZG9ja2VyID0gcmVxdWlyZSgnLi4vZG9ja2VyLWFwaScpXG5cbmNvbnN0IGNvbG9yID0gKGMpID0+IHtcbiAgcmV0dXJuIHRocm91Z2goKHB1c2gsIGNodW5rLCBlbmMsIGNiKSA9PiB7XG4gICAgcHVzaChmb3JtYXRbY10oY2h1bmspICsgJ1xcbicpXG4gICAgY2IoKVxuICB9KVxufVxuXG5jb25zdCBfYnVpbGRJbWFnZSA9ICh7ZmlsZSwgY29udGV4dCA9ICcuLycsIHRhZ3MgPSBbXSwgYXJncyA9IFtdfSkgPT4ge1xuICBjb25zdCB0YWdBcmdzID0gUi5mbGF0dGVuKHRhZ3MubWFwKHRhZyA9PiBbJy10JywgdGFnXSkpXG4gIGNvbnN0IGJ1aWxkQXJncyA9IFIucGlwZShcbiAgICBSLnRvUGFpcnMsXG4gICAgUi5tYXAoKFtrZXksIHZhbHVlXSkgPT4gWyctLWJ1aWxkLWFyZycsIGAke2tleX09JHt2YWx1ZX1gXSksXG4gICAgUi5mbGF0dGVuXG4gICkoYXJncylcbiAgY29uc3QgZG9ja2VyQXJncyA9IFsnYnVpbGQnLCAuLi50YWdBcmdzLCAuLi5idWlsZEFyZ3MsICctZicsIGZpbGUsIGNvbnRleHRdXG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGAgID4gZG9ja2VyICR7ZG9ja2VyQXJncy5qb2luKCcgJyl9XFxuYClcbiAgcmV0dXJuIHNwYXduKCdkb2NrZXInLCBkb2NrZXJBcmdzKVxufVxuXG5jb25zdCBidWlsZEltYWdlID0gKHNlcnZpY2VOYW1lLCBpbWFnZSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICBjb25zdCBwID0gX2J1aWxkSW1hZ2UoaW1hZ2UpXG4gIHAuc3Rkb3V0XG4gICAgLnBpcGUoc3BsaXQoKSlcbiAgICAucGlwZShjb2xvcigneWVsbG93JykpXG4gICAgLnBpcGUocHJlZml4TGluZXMoYCR7c2VydmljZU5hbWV9IHwgYCkpXG4gICAgLnBpcGUocHJvY2Vzcy5zdGRvdXQpXG4gIHAuc3RkZXJyXG4gICAgLnBpcGUoc3BsaXQoKSlcbiAgICAucGlwZShjb2xvcigncmVkJykpXG4gICAgLnBpcGUocHJlZml4TGluZXMoYCR7c2VydmljZU5hbWV9IHwgYCkpXG4gICAgLnBpcGUocHJvY2Vzcy5zdGRlcnIpXG4gIHBcbiAgICAub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgIC5vbignY2xvc2UnLCBleGl0Q29kZSA9PiBleGl0Q29kZSA9PT0gMCA/IHJlc29sdmUoKSA6IHJlamVjdChleGl0Q29kZSkpXG59KVxuXG5jb25zdCByZW1vdmVEYW5nbGluZyA9IChpbWFnZXNUaGF0TWF0Y2hlZFRhZ3MpID0+IHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKGltYWdlc1RoYXRNYXRjaGVkVGFnc1xuICAgIC5tYXAoaW1hZ2UgPT4gZG9ja2VyLmdldEltYWdlKGltYWdlLklkKS50aGVuKGluZm8gPT4ge1xuICAgICAgaWYgKCFpbmZvLlJlcG9UYWdzLmxlbmd0aCkgeyAvLyBubyBsb25nZXIgdGFnZ2VkIChpcyBkYW5nbGluZylcbiAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoXG4gICAgICAgICAgYFJlbW92aW5nIGRhbmdsaW5nIGltYWdlICR7aW5mby5JZH0sIHByZXZpb3VzbHkgdGFnZ2VkIFwiJHtpbWFnZS5SZXBvVGFncy5qb2luKCcgJyl9XCJcXG5gXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGRvY2tlci5ybWkoaW5mby5JZClcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH0pKVxuICApXG59XG5cbmNvbnN0IGJ1aWxkSW1hZ2VBbmRSZW1vdmVEYW5nbGluZyA9IGFzeW5jIChzZXJ2aWNlTmFtZSwgaW1hZ2UpID0+IHtcbiAgY29uc3QgaW1hZ2VzVGhhdE1hdGNoVGFncyA9IGF3YWl0IFByb21pc2UuYWxsKGltYWdlLnRhZ3MubWFwKHRhZyA9PiB7XG4gICAgcmV0dXJuIGRvY2tlci5nZXRJbWFnZSh0YWcpLmNhdGNoKGVyciA9PiB1bmRlZmluZWQpXG4gIH0pKVxuICBhd2FpdCBidWlsZEltYWdlKHNlcnZpY2VOYW1lLCBpbWFnZSlcbiAgYXdhaXQgcmVtb3ZlRGFuZ2xpbmcoaW1hZ2VzVGhhdE1hdGNoVGFncy5maWx0ZXIodiA9PiB2ICE9PSB1bmRlZmluZWQpKVxuICByZXR1cm5cbn1cblxuY29uc3QgYnVpbGRJbWFnZXMgPSB0b0J1aWxkID0+IHtcbiAgdHJ5IHtcbiAgICB0b0J1aWxkLmZvckVhY2goKFtuYW1lLCBpbWFnZXNdKSA9PiB7XG4gICAgICBpbWFnZXMuZm9yRWFjaChpbWFnZSA9PiB7XG4gICAgICAgIGlmICghKGltYWdlLmZpbGUgJiYgaW1hZ2UuZmlsZS5sZW5ndGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBEb2NrZXJmaWxlIHBhdGggZ2l2ZW4gZm9yIFwiJHtuYW1lfVwiIHNlcnZpY2UgaW1hZ2VgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gIH1cbiAgcmV0dXJuIHRvQnVpbGQucmVkdWNlKChwcm9taXNlLCBbbmFtZSwgaW1hZ2VzXSkgPT4ge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIGltYWdlcy5yZWR1Y2UoKHByb21pc2UsIGltYWdlKSA9PiB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKCkgPT4gYnVpbGRJbWFnZUFuZFJlbW92ZURhbmdsaW5nKG5hbWUsIGltYWdlKSlcbiAgICAgIH0sIFByb21pc2UucmVzb2x2ZSgpKVxuICAgIH0pXG4gIH0sIFByb21pc2UucmVzb2x2ZSgpKVxufVxuXG5jb25zdCBmaWx0ZXIgPSBSLnBpcGUoXG4gIFIudG9QYWlycyxcbiAgUi5tYXAoXG4gICAgUi5vdmVyKFxuICAgICAgUi5sZW5zSW5kZXgoMSksXG4gICAgICBSLnZpZXcoUi5sZW5zUHJvcCgnaW1hZ2UnKSlcbiAgICApXG4gICksXG4gIFIuZmlsdGVyKFxuICAgIFIucGlwZShcbiAgICAgIFIudmlldyhSLmxlbnNJbmRleCgxKSksXG4gICAgICBSLmJvdGgoQXJyYXkuaXNBcnJheSwgUi5jb21wbGVtZW50KFIuaXNFbXB0eSkpXG4gICAgKVxuICApXG4pXG5cbmNvbnN0IGJ1aWxkID0gKHNlbGVjdGVkU2VydmljZXMsIGNvbmZpZykgPT4ge1xuICByZXR1cm4gYnVpbGRJbWFnZXMoZmlsdGVyKHNlbGVjdGVkU2VydmljZXMpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkXG4iXX0=