function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var _require = require('child_process');

const exec = _require.exec;

const R = require('ramda');
const path = require('path');
const tryHook = require('../try-hook');
const build = require('./build');

var _require2 = require('figures-colored');

const tick = _require2.tick,
      cross = _require2.cross;

const prefixLines = require('prefix-stream-lines');
const format = require('chalk');
const connectLogs = require('./logs');

const dorcArgs = ['mode', 'hooks', 'image', 'cmd'];

const propTransforms = {
  volumes: value => {
    return value.map(v => {
      if (!path.isAbsolute(v)) {
        return ['-v', path.join(process.cwd(), v)];
      }
      return ['-v', value];
    });
  },
  env: value => R.toPairs(value).map(([k, v]) => ['-e', `${ k }=${ v }`]),
  ports: value => value.map(v => ['-p', v])
};

const getTransform = prop => {
  const transform = propTransforms[prop];
  if (!transform) {
    return (value, prop) => {
      if (Array.isArray(value)) {
        return value.map(v => ['--' + prop, v]);
      } else {
        return ['--' + prop, value];
      }
    };
  } else {
    return transform;
  }
};

const makeRunArgs = (service, containerName, detached = false) => {
  const dockerRunProps = R.pipe(() => service, R.omit(dorcArgs), R.assoc('name', containerName), R.toPairs)();
  const options = dockerRunProps.map(([key, value]) => {
    return getTransform(key)(value, key);
  });
  const cmd = R.ifElse(R.isNil, R.F, R.identity)(service.cmd);
  const detachedArg = R.ifElse(R.equals(false), R.identity, R.always('-d'))(detached);
  const args = R.flatten(['-it', detachedArg, options, service.image, cmd]).filter(v => v);
  return args;
};

const startService = (service, containerName, _args) => new Promise((resolve, reject) => {
  const args = ['run', ...makeRunArgs(service, containerName, true)];
  const cmd = `docker ${ args.join(' ') }`;
  process.stdout.write(`  > ${ cmd }\n\n`);
  const p = exec(cmd);
  p.stderr.pipe(process.stderr);
  p.on('close', exitCode => {
    exitCode !== 0 ? reject(exitCode) : resolve();
  });
});

const startServices = (services, config, args) => Promise.all(R.pipe(R.toPairs, R.addIndex(R.map)(([name, service], idx) => {
  const containerName = `${ config.project.name }_${ name }`;
  return tryHook('before-up', service, name).then(() => {
    return startService(service, containerName, args);
  }).then(() => {
    process.stdout.write(`${ tick } ${ name } is up\n`);
  }).catch(err => {
    process.stdout.write(`${ cross } could not start ${ name }\n`);
  });
}))(services));

const up = (() => {
  var _ref = _asyncToGenerator(function* (services, config, args) {
    yield build(services, config);
    return startServices(R.map(prepare)(services), config, args).then(function () {
      if (args.detached !== true) {
        return connectLogs(services, config);
      }
    });
  });

  return function up(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
})();

up.prepare = prepare;
up.makeRunArgs = makeRunArgs;

module.exports = up;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9oYW5kbGVyL29sZC91cC5qcyJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiZXhlYyIsIlIiLCJwYXRoIiwidHJ5SG9vayIsImJ1aWxkIiwidGljayIsImNyb3NzIiwicHJlZml4TGluZXMiLCJmb3JtYXQiLCJjb25uZWN0TG9ncyIsImRvcmNBcmdzIiwicHJvcFRyYW5zZm9ybXMiLCJ2b2x1bWVzIiwidmFsdWUiLCJtYXAiLCJ2IiwiaXNBYnNvbHV0ZSIsImpvaW4iLCJwcm9jZXNzIiwiY3dkIiwiZW52IiwidG9QYWlycyIsImsiLCJwb3J0cyIsImdldFRyYW5zZm9ybSIsInByb3AiLCJ0cmFuc2Zvcm0iLCJBcnJheSIsImlzQXJyYXkiLCJtYWtlUnVuQXJncyIsInNlcnZpY2UiLCJjb250YWluZXJOYW1lIiwiZGV0YWNoZWQiLCJkb2NrZXJSdW5Qcm9wcyIsInBpcGUiLCJvbWl0IiwiYXNzb2MiLCJvcHRpb25zIiwia2V5IiwiY21kIiwiaWZFbHNlIiwiaXNOaWwiLCJGIiwiaWRlbnRpdHkiLCJkZXRhY2hlZEFyZyIsImVxdWFscyIsImFsd2F5cyIsImFyZ3MiLCJmbGF0dGVuIiwiaW1hZ2UiLCJmaWx0ZXIiLCJzdGFydFNlcnZpY2UiLCJfYXJncyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic3Rkb3V0Iiwid3JpdGUiLCJwIiwic3RkZXJyIiwib24iLCJleGl0Q29kZSIsInN0YXJ0U2VydmljZXMiLCJzZXJ2aWNlcyIsImNvbmZpZyIsImFsbCIsImFkZEluZGV4IiwibmFtZSIsImlkeCIsInByb2plY3QiLCJ0aGVuIiwiY2F0Y2giLCJlcnIiLCJ1cCIsInByZXBhcmUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztlQUFlQSxRQUFRLGVBQVIsQzs7TUFBUkMsSSxZQUFBQSxJOztBQUNQLE1BQU1DLElBQUlGLFFBQVEsT0FBUixDQUFWO0FBQ0EsTUFBTUcsT0FBT0gsUUFBUSxNQUFSLENBQWI7QUFDQSxNQUFN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Y2hpbGRfcHJvY2VzcycpXG5jb25zdCBSID0gcmVxdWlyZSgncmFtZGEnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgdHJ5SG9vayA9IHJlcXVpcmUoJy4uL3RyeS1ob29rJylcbmNvbnN0IGJ1aWxkID0gcmVxdWlyZSgnLi9idWlsZCcpXG5jb25zdCB7dGljaywgY3Jvc3N9ID0gcmVxdWlyZSgnZmlndXJlcy1jb2xvcmVkJylcbmNvbnN0IHByZWZpeExpbmVzID0gcmVxdWlyZSgncHJlZml4LXN0cmVhbS1saW5lcycpXG5jb25zdCBmb3JtYXQgPSByZXF1aXJlKCdjaGFsaycpXG5jb25zdCBjb25uZWN0TG9ncyA9IHJlcXVpcmUoJy4vbG9ncycpXG5cbmNvbnN0IGRvcmNBcmdzID0gW1xuICAnbW9kZScsXG4gICdob29rcycsXG4gICdpbWFnZScsXG4gICdjbWQnXG5dXG5cbmNvbnN0IHByb3BUcmFuc2Zvcm1zID0ge1xuICB2b2x1bWVzOiB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcCh2ID0+IHtcbiAgICAgIGlmICghcGF0aC5pc0Fic29sdXRlKHYpKSB7XG4gICAgICAgIHJldHVybiBbJy12JywgcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIHYpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIFsnLXYnLCB2YWx1ZV1cbiAgICB9KVxuICB9LFxuICBlbnY6IHZhbHVlID0+IFIudG9QYWlycyh2YWx1ZSkubWFwKChbaywgdl0pID0+IFsnLWUnLCBgJHtrfT0ke3Z9YF0pLFxuICBwb3J0czogdmFsdWUgPT4gdmFsdWUubWFwKHYgPT4gWyctcCcsIHZdKVxufVxuXG5jb25zdCBnZXRUcmFuc2Zvcm0gPSBwcm9wID0+IHtcbiAgY29uc3QgdHJhbnNmb3JtID0gcHJvcFRyYW5zZm9ybXNbcHJvcF1cbiAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCh2ID0+IFsnLS0nICsgcHJvcCwgdl0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWyctLScgKyBwcm9wLCB2YWx1ZV1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVxuICB9XG59XG5cbmNvbnN0IG1ha2VSdW5BcmdzID0gKHNlcnZpY2UsIGNvbnRhaW5lck5hbWUsIGRldGFjaGVkID0gZmFsc2UpID0+IHtcbiAgY29uc3QgZG9ja2VyUnVuUHJvcHMgPSBSLnBpcGUoXG4gICAgKCkgPT4gc2VydmljZSxcbiAgICBSLm9taXQoZG9yY0FyZ3MpLFxuICAgIFIuYXNzb2MoJ25hbWUnLCBjb250YWluZXJOYW1lKSxcbiAgICBSLnRvUGFpcnNcbiAgKSgpXG4gIGNvbnN0IG9wdGlvbnMgPSBkb2NrZXJSdW5Qcm9wcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIHJldHVybiBnZXRUcmFuc2Zvcm0oa2V5KSh2YWx1ZSwga2V5KVxuICB9KVxuICBjb25zdCBjbWQgPSBSLmlmRWxzZShSLmlzTmlsLCBSLkYsIFIuaWRlbnRpdHkpKHNlcnZpY2UuY21kKVxuICBjb25zdCBkZXRhY2hlZEFyZyA9IFIuaWZFbHNlKFIuZXF1YWxzKGZhbHNlKSwgUi5pZGVudGl0eSwgUi5hbHdheXMoJy1kJykpKGRldGFjaGVkKVxuICBjb25zdCBhcmdzID0gUi5mbGF0dGVuKFsnLWl0JywgZGV0YWNoZWRBcmcsIG9wdGlvbnMsIHNlcnZpY2UuaW1hZ2UsIGNtZF0pXG4gICAgLmZpbHRlcih2ID0+IHYpXG4gIHJldHVybiBhcmdzXG59XG5cbmNvbnN0IHN0YXJ0U2VydmljZSA9IChzZXJ2aWNlLCBjb250YWluZXJOYW1lLCBfYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICBjb25zdCBhcmdzID0gWydydW4nLCAuLi5tYWtlUnVuQXJncyhzZXJ2aWNlLCBjb250YWluZXJOYW1lLCB0cnVlKV1cbiAgY29uc3QgY21kID0gYGRvY2tlciAke2FyZ3Muam9pbignICcpfWBcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYCAgPiAke2NtZH1cXG5cXG5gKVxuICBjb25zdCBwID0gZXhlYyhjbWQpXG4gIHAuc3RkZXJyLnBpcGUocHJvY2Vzcy5zdGRlcnIpXG4gIHAub24oJ2Nsb3NlJywgZXhpdENvZGUgPT4ge1xuICAgIGV4aXRDb2RlICE9PSAwID8gcmVqZWN0KGV4aXRDb2RlKSA6IHJlc29sdmUoKVxuICB9KVxufSlcblxuY29uc3Qgc3RhcnRTZXJ2aWNlcyA9IChzZXJ2aWNlcywgY29uZmlnLCBhcmdzKSA9PiBQcm9taXNlLmFsbChSLnBpcGUoXG4gIFIudG9QYWlycyxcbiAgUi5hZGRJbmRleChSLm1hcCkoKFtuYW1lLCBzZXJ2aWNlXSwgaWR4KSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyTmFtZSA9IGAke2NvbmZpZy5wcm9qZWN0Lm5hbWV9XyR7bmFtZX1gXG4gICAgcmV0dXJuIHRyeUhvb2soJ2JlZm9yZS11cCcsIHNlcnZpY2UsIG5hbWUpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBzdGFydFNlcnZpY2Uoc2VydmljZSwgY29udGFpbmVyTmFtZSwgYXJncylcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGAke3RpY2t9ICR7bmFtZX0gaXMgdXBcXG5gKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtjcm9zc30gY291bGQgbm90IHN0YXJ0ICR7bmFtZX1cXG5gKVxuICAgICAgfSlcbiAgfSlcbikoc2VydmljZXMpKVxuXG5jb25zdCB1cCA9IGFzeW5jIChzZXJ2aWNlcywgY29uZmlnLCBhcmdzKSA9PiB7XG4gIGF3YWl0IGJ1aWxkKHNlcnZpY2VzLCBjb25maWcpXG4gIHJldHVybiBzdGFydFNlcnZpY2VzKFIubWFwKHByZXBhcmUpKHNlcnZpY2VzKSwgY29uZmlnLCBhcmdzKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGlmIChhcmdzLmRldGFjaGVkICE9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0TG9ncyhzZXJ2aWNlcywgY29uZmlnKVxuICAgICAgfVxuICAgIH0pXG59XG5cbnVwLnByZXBhcmUgPSBwcmVwYXJlXG51cC5tYWtlUnVuQXJncyA9IG1ha2VSdW5BcmdzXG5cbm1vZHVsZS5leHBvcnRzID0gdXBcbiJdfQ==